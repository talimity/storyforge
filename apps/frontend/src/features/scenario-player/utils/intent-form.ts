import type {
  IntentInput,
  IntentKind,
  PlayEnvironmentOutput,
  TimelineTurn,
} from "@storyforge/contracts";
import { assertNever } from "@storyforge/utils";
import { z } from "zod";

type ScenarioParticipant = PlayEnvironmentOutput["participants"][number];

export const INTENT_KIND_CONFIG: Record<
  IntentKind,
  { requiresTarget: boolean; allowsTarget: boolean; requiresText: boolean }
> = {
  manual_control: { requiresTarget: true, allowsTarget: true, requiresText: true },
  guided_control: { requiresTarget: true, allowsTarget: true, requiresText: true },
  narrative_constraint: { requiresTarget: false, allowsTarget: true, requiresText: true },
  continue_story: { requiresTarget: false, allowsTarget: true, requiresText: false },
};

const TEXT_LIMIT = 50_000;

const requiredTextSchema = z
  .string()
  .max(TEXT_LIMIT, "Guidance is too long")
  .refine((value) => value.trim().length > 0, {
    message: "Enter some guidance",
  });

const replaySettingsSchema = z.object({
  replayMode: z.enum(["full", "resume"]),
  replayResumeStepId: z.string().nullable(),
  replayOverrides: z.record(z.string(), z.record(z.string(), z.string())).default({}).optional(),
});

const baseIntentSchema = z.discriminatedUnion("kind", [
  z.object({
    kind: z.literal("manual_control"),
    characterId: z.string().min(1, "Select a character"),
    text: requiredTextSchema,
  }),
  z.object({
    kind: z.literal("guided_control"),
    characterId: z.string().min(1, "Select a character"),
    text: requiredTextSchema,
  }),
  z.object({
    kind: z.literal("narrative_constraint"),
    characterId: z.string().nullable().optional(),
    text: requiredTextSchema,
  }),
  z.object({
    kind: z.literal("continue_story"),
    characterId: z.string().nullable().optional(),
    text: z.string().max(TEXT_LIMIT, "Guidance is too long"),
  }),
]);

export const intentFormSchema = baseIntentSchema.and(replaySettingsSchema);

export type IntentFormValues = z.infer<typeof intentFormSchema>;

export const intentFormDefaultValues: IntentFormValues = {
  kind: "continue_story",
  characterId: null,
  text: "",
  replayMode: "full",
  replayResumeStepId: null,
  replayOverrides: {},
};

export function getInitialIntentFormValues(
  turn: TimelineTurn | null,
  participants: ScenarioParticipant[]
): IntentFormValues {
  // If this turn is not the first effect generated by an intent run, we should
  // not reuse the intent inputs because they generally only apply to the first
  // effect (subsequent effects are usually just continuations).
  if (!turn?.provenance || turn.provenance.effectSequence > 0) {
    return {
      kind: "continue_story",
      characterId: null,
      text: "",
      replayMode: "full",
      replayResumeStepId: null,
      replayOverrides: {},
    };
  }

  const { intentKind, inputText, targetParticipantId } = turn.provenance;
  const participant = targetParticipantId
    ? (participants.find((p) => p.id === targetParticipantId) ?? null)
    : null;
  const characterId = participant?.characterId ?? null;
  const text = inputText ?? "";

  switch (intentKind) {
    case "manual_control":
      return {
        kind: "manual_control",
        characterId: characterId ?? "",
        text,
        replayMode: "full",
        replayResumeStepId: null,
        replayOverrides: {},
      };
    case "guided_control":
      return {
        kind: "guided_control",
        characterId: characterId ?? "",
        text,
        replayMode: "full",
        replayResumeStepId: null,
        replayOverrides: {},
      };
    case "narrative_constraint":
      return {
        kind: "narrative_constraint",
        characterId,
        text,
        replayMode: "full",
        replayResumeStepId: null,
        replayOverrides: {},
      };
    case "continue_story":
      return {
        kind: "continue_story",
        characterId,
        text,
        replayMode: "full",
        replayResumeStepId: null,
        replayOverrides: {},
      };
    default: {
      const exhaustiveCheck: never = intentKind;
      throw new Error(`Unsupported intent kind: ${exhaustiveCheck}`);
    }
  }
}

export function createIntentInputPayload(
  values: IntentFormValues,
  participants: ScenarioParticipant[]
): IntentInput {
  switch (values.kind) {
    case "manual_control":
    case "guided_control": {
      const participant = participants.find((p) => p.characterId === values.characterId);
      if (!participant) {
        throw new Error("Character selection could not be resolved to a participant");
      }
      return {
        kind: values.kind,
        targetParticipantId: participant.id,
        text: values.text.trim(),
      };
    }
    case "narrative_constraint":
      if (values.characterId) {
        const participant = participants.find((p) => p.characterId === values.characterId);
        if (!participant) {
          throw new Error("Character selection could not be resolved to a participant");
        }
        return {
          kind: "narrative_constraint",
          text: values.text.trim(),
          targetParticipantId: participant.id,
        };
      }
      return {
        kind: "narrative_constraint",
        text: values.text.trim(),
      };
    case "continue_story":
      if (values.characterId) {
        const participant = participants.find((p) => p.characterId === values.characterId);
        if (!participant) {
          throw new Error("Character selection could not be resolved to a participant");
        }
        return {
          kind: "continue_story",
          targetParticipantId: participant.id,
        };
      }
      return { kind: "continue_story" };
    default: {
      assertNever(values);
    }
  }
}
